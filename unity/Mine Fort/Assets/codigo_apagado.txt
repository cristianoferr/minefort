---- ARQ: 

---- ARQ: 

---- ARQ: 

---- ARQ: MouseController

namespace MineFort.controllers
{
    public class MouseController : MonoBehaviour
    {

        public GameObject circleCursorPrefab;

        // The world-position of the mouse last frame.
        Vector3 lastFramePosition;
        Vector3 currFramePosition;
        Vector3 currIsoPosition;

        // The world-position start of our left-mouse drag operation
        Vector3 dragStartPosition;
        List<GameObject> dragPreviewGameObjects;

        BuildModeController bmc;
        FurnitureSpriteController fsc;

        bool isDragging = false;

        enum MouseMode
        {
            SELECT,
            BUILD
        }
        MouseMode currentMode = MouseMode.SELECT;

        // Use this for initialization
        void Start()
        {
            currentMode = MouseMode.BUILD;
            bmc = GameObject.FindObjectOfType<BuildModeController>();

            fsc = GameObject.FindObjectOfType<FurnitureSpriteController>();


            dragPreviewGameObjects = new List<GameObject>();

            // Center the Camera
            Vector3 pos =Utils.TwoDToIso(WorldController.Instance.world.width / 2, WorldController.Instance.world.height / 2,0);
            pos.z = Camera.main.transform.position.z;
            Camera.main.transform.position = pos;
        }

        /// <summary>
        /// Gets the mouse position in world space.
        /// </summary>
        public Vector3 GetMousePosition()
        {
            return currFramePosition;
        }

        public Tile GetMouseOverTile()
        {

            return WorldController.Instance.GetTileAtWorldCoord(currFramePosition);
        }

        // Update is called once per frame
        void Update()
        {
            if (WorldController.Instance.IsModal)
            {
                // A modal dialog is open, so don't process any game inputs from the mouse
                return;
            }

            currFramePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            currIsoPosition = Utils.IsoTo2D(currFramePosition.x, currFramePosition.y);
            currFramePosition.z = 0;

            if (Input.GetKeyUp(KeyCode.Escape))
            {
                if (currentMode == MouseMode.BUILD)
                {
                    currentMode = MouseMode.SELECT;
                }
                else if (currentMode == MouseMode.SELECT)
                {
                    Debug.Log("Show game menu?");
                }
            }

            //UpdateCursor();

            UpdateDragging();
            UpdateCameraMovement();
            UpdateSelection();
            // Save the mouse position from this frame
            // We don't use currFramePosition because we may have moved the camera.
            lastFramePosition = Camera.main.ScreenToWorldPoint(Input.mousePosition);
            lastFramePosition.z = 0;
        }

        public class SelectionInfo
        {
            public Tile tile;
            public ISelectableInterface[] stuffInTile;
            public int subSelection = 0;
        }

        public SelectionInfo mySelection;

        void UpdateSelection()
        {
            // This handles us left-clicking on furniture or characters to set a selection.

            if (Input.GetKeyUp(KeyCode.Escape))
            {
                mySelection = null;
            }

            if (currentMode != MouseMode.SELECT)
            {
                return;
            }

            // If we're over a UI element, then bail out from this.
            if (EventSystem.current.IsPointerOverGameObject())
            {
                return;
            }

            if (Input.GetMouseButtonUp(0))
            {
                // We just release the mouse button, so that's our queue to update our selection.
                Tile tileUnderMouse = GetMouseOverTile();

                if (tileUnderMouse == null)
                {
                    // No valid tile under mouse
                    return;
                }


                if (mySelection == null || mySelection.tile != tileUnderMouse)
                {
                    //Debug.Log("new tile");
                    // We have just selected a brand new tile, reset the info.
                    mySelection = new SelectionInfo();
                    mySelection.tile = tileUnderMouse;
                    RebuildSelectionStuffInTile();

                    // Select the first non-null entry.
                    for (int i = 0; i < mySelection.stuffInTile.Length; i++)
                    {
                        if (mySelection.stuffInTile[i] != null)
                        {
                            mySelection.subSelection = i;
                            break;
                        }
                    }
                }
                else
                {
                    // This is the same tile we already have selected, so cycle the subSelection to the next non-null item.
                    // Not that the tile sub selection can NEVER be null, so we know we'll always find something.

                    // Rebuild the array of possible sub-selection in case characters moved in or out of the tile.
                    RebuildSelectionStuffInTile();

                    do
                    {
                        mySelection.subSelection = (mySelection.subSelection + 1) % mySelection.stuffInTile.Length;
                    } while (mySelection.stuffInTile[mySelection.subSelection] == null);
                }
                Debug.Log(mySelection.subSelection);
            }
        }

        void RebuildSelectionStuffInTile()
        {

            // Make sure stuffInTile is big enough to handle all the characters, plus the 3 extra values
            mySelection.stuffInTile = new ISelectableInterface[mySelection.tile.charactersCount + 3];

            // Copy the character references
            for (int i = 0; i < mySelection.tile.charactersCount; i++)
            {
                mySelection.stuffInTile[i] = mySelection.tile.characters[i];
            }

            // Now assign references to the other three sub-selections available
            mySelection.stuffInTile[mySelection.stuffInTile.Length - 3] = mySelection.tile.furniture;
            mySelection.stuffInTile[mySelection.stuffInTile.Length - 2] = mySelection.tile.inventory;
            mySelection.stuffInTile[mySelection.stuffInTile.Length - 1] = mySelection.tile;

        }

        void UpdateDragging()
        {
            // If we're over a UI element, then bail out from this.
            if (EventSystem.current.IsPointerOverGameObject())
            {
                return;
            }

            // Clean up old drag previews
            while (dragPreviewGameObjects.Count > 0)
            {
                GameObject go = dragPreviewGameObjects[0];
                dragPreviewGameObjects.RemoveAt(0);
                SimplePool.Despawn(go);
            }

            if (currentMode != MouseMode.BUILD)
            {
                return;
            }

            // Start Drag
            if (Input.GetMouseButtonDown(0))
            {
                dragStartPosition = currIsoPosition;
                isDragging = true;
            }
            else if (isDragging == false)
            {
                dragStartPosition = currIsoPosition;
            }

            if (Input.GetMouseButtonUp(1) || Input.GetKeyUp(KeyCode.Escape))
            {
                // The RIGHT mouse button was released, so we
                // are cancelling any dragging/build mode.
                isDragging = false;
            }

            if (bmc.IsObjectDraggable() == false)
            {
                dragStartPosition = currIsoPosition;
            }

            Vector3 dragEndPosition = currIsoPosition;
            int start_x = Mathf.FloorToInt(dragStartPosition.x + 0.5f);
            int end_x = Mathf.FloorToInt(dragEndPosition.x + 0.5f);
            int start_y = Mathf.FloorToInt(dragStartPosition.y + 0.5f);
            int end_y = Mathf.FloorToInt(dragEndPosition.y + 0.5f);

            // We may be dragging in the "wrong" direction, so flip things if needed.
            if (end_x < start_x)
            {
                int tmp = end_x;
                end_x = start_x;
                start_x = tmp;
            }
            if (end_y < start_y)
            {
                int tmp = end_y;
                end_y = start_y;
                start_y = tmp;
            }

            //if( isDragging ) {
            // Display a preview of the drag area
            //TODO: melhorar essa limitação
            //if (Math.Abs(end_x - start_x) > 20) end_x = start_x + 20;
           // if (Math.Abs(end_y - start_y) > 20) end_y = start_y + 20;
            for (int x = start_x; x <= end_x; x++)
            {
                for (int y = start_y; y <= end_y; y++)
                {
                    Tile t = WorldController.Instance.world.GetTileAt(x, y);
                    if (t != null)
                    {
                        // Display the building hint on top of this tile position

                        if (bmc.buildMode == GameConsts.BuildMode.FURNITURE)
                        {
                            ShowFurnitureSpriteAtTile(bmc.buildModeObjectType, t);
                        }
                        else
                        {
                            // show the generic dragging visuals
                            GameObject go = SimplePool.Spawn(circleCursorPrefab, Utils.TwoDToIso(x,y,0), Quaternion.identity);
                            go.transform.SetParent(this.transform, true);
                            dragPreviewGameObjects.Add(go);
                        }

                    }
                }
            }
            //}

            // End Drag
            if (isDragging && Input.GetMouseButtonUp(0))
            {
                isDragging = false;

                // Loop through all the tiles
                for (int x = start_x; x <= end_x; x++)
                {
                    for (int y = start_y; y <= end_y; y++)
                    {
                        Tile t = WorldController.Instance.world.GetTileAt(x-0.5f, y - 0.5f);

                        if (t != null)
                        {
                            // Call BuildModeController::DoBuild()
                            bmc.DoBuild(t);
                        }
                    }
                }
            }
        }

        void UpdateCameraMovement()
        {
            // Handle screen panning
            if (Input.GetMouseButton(1) || Input.GetMouseButton(2))
            {	// Right or Middle Mouse Button

                Vector3 diff = lastFramePosition - currFramePosition;
                Camera.main.transform.Translate(diff);

            }

            Camera.main.orthographicSize -= Camera.main.orthographicSize * Input.GetAxis("Mouse ScrollWheel");

            Camera.main.orthographicSize = Mathf.Clamp(Camera.main.orthographicSize, 3f, GameConsts.CAM_MAX_DISTANCE);
        }

        void ShowFurnitureSpriteAtTile(string furnitureType, Tile t)
        {

            GameObject go = new GameObject();
            go.transform.SetParent(this.transform, true);
            dragPreviewGameObjects.Add(go);


            SpriteRenderer sr = go.AddComponent<SpriteRenderer>();
            sr.sortingLayerName = "Jobs";
            sr.sprite = fsc.GetSpriteForFurniture(furnitureType);

            if (WorldController.Instance.world.IsFurniturePlacementValid(furnitureType, t))
            {
                sr.color = new Color(0.5f, 1f, 0.5f, 0.25f);
            }
            else
            {
                sr.color = new Color(1f, 0.5f, 0.5f, 0.25f);
            }

            Furniture proto = World.current.furniturePrototypes[furnitureType];

            go.transform.position = new Vector3(t.X + ((proto.width - 1) / 2f), t.Y + ((proto.height - 1) / 2f), 0);

        }

        public void StartBuildMode()
        {
            currentMode = MouseMode.BUILD;
        }


    }

}


---- ARQ: TileSpriteController
using MineFort.model.entities;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace MineFort.controllers
{
    public class TileSpriteController : MonoBehaviour
    {

        Dictionary<Tile, GameObject> tileGameObjectMap;

        World world
        {
            get { return World.current; }
        }

        // Use this for initialization
        void Start()
        {
            // Instantiate our dictionary that tracks which GameObject is rendering which Tile data.
            tileGameObjectMap = new Dictionary<Tile, GameObject>();

            // Create a GameObject for each of our tiles, so they show visually. (and redunt reduntantly)
            for (int x = 0; x < world.mapData.width; x++)
            {
                for (int y = 0; y < world.mapData.height; y++)
                {
                    // Get the tile data
                    Tile tile_data = world.mapData.GetTileAt(x, y);

                    // This creates a new GameObject and adds it to our scene.
                    GameObject tile_go = new GameObject();

                    // Add our tile/GO pair to the dictionary.
                    tileGameObjectMap.Add(tile_data, tile_go);

                    tile_go.name = "Tile_" + x + "_" + y;
                   // tile_go.transform.position = new Vector3(tile_data.X, tile_data.Y, 0);
                    tile_go.transform.SetParent(this.transform, true);

                    // Add a Sprite Renderer
                    // Add a default sprite for empty tiles.
                    SpriteRenderer sr = tile_go.AddComponent<SpriteRenderer>();
                    sr.sprite = SpriteManager.current.GetSprite("Tile", tile_data.Type.fileName);
                    sr.sortingLayerName = "Tiles";

                    OnTileChanged(tile_data);
                }
            }

            // Register our callback so that our GameObject gets updated whenever
            // the tile's type changes.
            world.mapData.RegisterTileChanged(OnTileChanged);
        }

        // THIS IS AN EXAMPLE -- NOT CURRENTLY USED (and probably out of date)
        void DestroyAllTileGameObjects()
        {
            // This function might get called when we are changing floors/levels.
            // We need to destroy all visual **GameObjects** -- but not the actual tile data!

            while (tileGameObjectMap.Count > 0)
            {
                Tile tile_data = tileGameObjectMap.Keys.First();
                GameObject tile_go = tileGameObjectMap[tile_data];

                // Remove the pair from the map
                tileGameObjectMap.Remove(tile_data);

                // Unregister the callback!
                tile_data.UnregisterTileTypeChangedCallback(OnTileChanged);

                // Destroy the visual GameObject
                Destroy(tile_go);
            }

            // Presumably, after this function gets called, we'd be calling another
            // function to build all the GameObjects for the tiles on the new floor/level
        }

        // This function should be called automatically whenever a tile's data gets changed.
        void OnTileChanged(Tile tile_data)
        {

            if (tileGameObjectMap.ContainsKey(tile_data) == false)
            {
                Debug.LogError("tileGameObjectMap doesn't contain the tile_data -- did you forget to add the tile to the dictionary? Or maybe forget to unregister a callback?");
                return;
            }

            GameObject tile_go = tileGameObjectMap[tile_data];

            if (tile_go == null)
            {
                Debug.LogError("tileGameObjectMap's returned GameObject is null -- did you forget to add the tile to the dictionary? Or maybe forget to unregister a callback?");
                return;
            }

            tile_go.GetComponent<SpriteRenderer>().sprite = SpriteManager.current.GetSprite("Tile", tile_data.Type.fileName);
            tile_go.transform.position = CalcPosition( tile_data);
            /*if (tile_data.Type == GameConsts.TileType.Floor)
            {
                tile_go.GetComponent<SpriteRenderer>().sprite = SpriteManager.current.GetSprite("Tile", "Floor");
            }
            else if (tile_data.Type == GameConsts.TileType.Empty)
            {
                tile_go.GetComponent<SpriteRenderer>().sprite = SpriteManager.current.GetSprite("Tile", "Empty");
            }
            else
            {
                Debug.LogError("OnTileTypeChanged - Unrecognized tile type.");
            }*/


        }
        private Vector3 CalcPosition( Tile tile)
        {
            
            Vector3 pos = Utils.TwoDToIso(tile.X, tile.Y, tile.height);
            return pos;
        }



    }
}

----- ARQ: WorldController

using System;
using MineFort.model.entities;
using UnityEngine;
using UnityEngine.SceneManagement;

namespace MineFort.controllers
{
    public class WorldController : MonoBehaviour
    {

        public static WorldController Instance { get; protected set; }

        // The world and tile data
        public World world { get; protected set; }

        static string loadWorldFromFile = null;

        private bool _isPaused = false;
        public bool IsPaused
        {
            get
            {
                return _isPaused || IsModal;
            }
            set
            {
                _isPaused = value;
            }
        }

        void Start()
        {
        }

        public bool IsModal; // If true, a modal dialog box is open so normal inputs should be ignored.

        // Use this for initialization
        void OnEnable()
        {
            if (Instance != null)
            {
                Debug.LogError("There should never be two world controllers.");
            }
            Instance = this;

            if (loadWorldFromFile != null)
            {
                //CreateWorldFromSaveFile();
                loadWorldFromFile = null;
            }
            else
            {
                CreateEmptyWorld();
            }
        }

        void Update()
        {
            // TODO: Add pause/unpause, speed controls, etc...
            if (IsPaused == false)
            {
                world.Update(Time.deltaTime);
            }

        }

        /// <summary>
        /// Gets the tile at the unity-space coordinates
        /// </summary>
        /// <returns>The tile at world coordinate.</returns>
        /// <param name="coord">Unity World-Space coordinates.</param>
        public Tile GetTileAtWorldCoord(Vector3 coord)
        {
            int x = Mathf.FloorToInt(coord.x + 0.5f);
            int y = Mathf.FloorToInt(coord.y + 0.5f);
            return world.GetTileAt(Utils.IsoTo2D(x, y));
        }

        public void NewWorld()
        {
            Debug.Log("NewWorld button was clicked.");

            SceneManager.LoadScene(SceneManager.GetActiveScene().name);
        }


        public string FileSaveBasePath()
        {
            return System.IO.Path.Combine(Application.persistentDataPath, "Saves");

        }



        public void LoadWorld(string fileName)
        {
            Debug.Log("LoadWorld button was clicked.");

            // Reload the scene to reset all data (and purge old references)
            loadWorldFromFile = fileName;
            SceneManager.LoadScene(SceneManager.GetActiveScene().name);

        }

        void CreateEmptyWorld()
        {
            // Create a world with Empty tiles
            //world = new World(100, 100);
            world = World.current;
            world.Start();
            RandomizeWorld(world,"land");
        }

        private void RandomizeWorld(World world,string tag=null)
        {
            for (int x = 0; x < world.width; x++)
            {
                for (int y = 0; y < world.width; y++)
                {
                    Tile tile = world.GetTileAt(x, y);
                    //this ignore the biome...
                    tile.Type = world.biomes.GetTileTypeWithTag(tag);
                }
            }
        }

        /*void CreateWorldFromSaveFile()
        {
            Debug.Log("CreateWorldFromSaveFile");
            // Create a world from our save file data.

            XmlSerializer serializer = new XmlSerializer(typeof(World));

            // This can throw an exception.
            // TODO: Show a error message to the user.
            string saveGameText = File.ReadAllText(loadWorldFromFile);

            TextReader reader = new StringReader(saveGameText);


            Debug.Log(reader.ToString());
            world = (World)serializer.Deserialize(reader);
            reader.Close();



            // Center the Camera
            Camera.main.transform.position = new Vector3(world.Width / 2, world.Height / 2, Camera.main.transform.position.z);

        }*/

    }

}


----- ARQ: World

using System;
using System.Collections.Generic;
using UnityEngine;
using MineFort.model.entities.map;
using System.Xml;
using System.IO;
using MineFort.model.furniture;
using MineFort.model.inventory;
using MoonSharp.Interpreter;

namespace MineFort.model.entities
{
    [MoonSharpUserData]
    public class World_Old : GameEntity
    {
        public Dictionary<string, Furniture> furniturePrototypes;

        private World_Old()
        {
            
            SetupWorld(GameConsts.WORLD_WIDTH, GameConsts.WORLD_HEIGHT);

        }

       public override  void Start()
        {
            CreateFurniturePrototypes();
            CreateCharacter(GetTileAt(width / 2, height / 2));
        }


        private void SetupWorld(int width, int height)
        {
            mapData.SetupWorld(width, height);
            jobQueue = new JobQueue(); 
        }


        //singleton
        static World world_;
        public static World current
        {
            get
            {
                //mundo será instanciado vazio.
                if (world_ == null)
                {
                    world_ = new World();
                }
                return world_;
            }
            set
            {
                world_ = value;
            }
        }
       

        #region properties
        public Path_TileGraph tileGraph;
        public Dictionary<string, Job> furnitureJobPrototypes;


        #endregion properties

        public GameCharacter CreateCharacter(Tile t)
        {
            Debug.Log("CreateCharacter");
            GameCharacter c = new GameCharacter();
            c.CurrTile = t;
            AddEntity(c);

            if (cbCharacterCreated != null)
                cbCharacterCreated(c);

            return c;
        }

        public bool ContainsEntity(PhysicalEntity pawn)
        {
            return entities.Contains(pawn);
        }

        public void OnInventoryCreated(GameInventory inv)
        {
            if (cbInventoryCreated != null)
                cbInventoryCreated(inv);
        }

        public void OnFurnitureRemoved(PhysicalEntity furn)
        {
            AddEntity(furn);
        }

        internal PhysicalEntity AddEntity(PhysicalEntity entity)
        {
            if (entities.Contains(entity))
            {
                Utils.LogError("Entities already contains "+entity);
            }
            entities.Add(entity);
            return entity;
        }

       
        #region Callbacks

        Action<Furniture> cbFurnitureCreated;
        Action<MovableEntity> cbCharacterCreated;
        Action<GameInventory> cbInventoryCreated;
        

        public void RegisterFurnitureCreated(Action<Furniture> callbackfunc)
        {
            cbFurnitureCreated += callbackfunc;
        }

        public void UnregisterFurnitureCreated(Action<Furniture> callbackfunc)
        {
            cbFurnitureCreated -= callbackfunc;
        }

        public void RegisterCharacterCreated(Action<MovableEntity> callbackfunc)
        {
            cbCharacterCreated += callbackfunc;
        }

        public void UnregisterCharacterCreated(Action<MovableEntity> callbackfunc)
        {
            cbCharacterCreated -= callbackfunc;
        }

        public void RegisterInventoryCreated(Action<GameInventory> callbackfunc)
        {
            cbInventoryCreated += callbackfunc;
        }

        public void UnregisterInventoryCreated(Action<GameInventory> callbackfunc)
        {
            cbInventoryCreated -= callbackfunc;
        }

       

        public void DeleteRoom(Room r)
        {
            r.chunk.DeleteRoom(r);
        }

        #endregion Callbacks

        public void InvalidateTileGraph()
        {
            tileGraph = null;
        }

        public override void Update(float deltaTime)
        {
            base.Update(deltaTime);
            foreach (PhysicalEntity c in entities)
            {
                c.Update(deltaTime);
            }

        }

        public Tile GetTileAt(float x, float y)
        {
            return mapData.GetTileAt(x, y);
        }

        public Tile GetTileAt(Vector3 pos)
        {
            return mapData.GetTileAt(pos.x,pos.y);
        }


        // TODO: Most likely this will be replaced with a dedicated
        // class for managing job queues (plural!) that might also
        // be semi-static or self initializing or some damn thing.
        // For now, this is just a PUBLIC member of World
        public JobQueue jobQueue;
        public Biomes biomes;

        #region Furniture
        


        public void SetFurnitureJobPrototype(Job j, Furniture f)
        {
            furnitureJobPrototypes[f.objectType] = j;
        }

        void LoadFurnitureLua()
        {
            string filePath = System.IO.Path.Combine(Application.streamingAssetsPath, "LUA");
            filePath = System.IO.Path.Combine(filePath, "Furniture.lua");
            string myLuaCode = System.IO.File.ReadAllText(filePath);

            //Debug.Log("My LUA Code");
            //Debug.Log(myLuaCode);

            // Instantiate the singleton
            new FurnitureActions(myLuaCode);

        }

        void CreateFurniturePrototypes()
        {
            LoadFurnitureLua();


            furniturePrototypes = new Dictionary<string, Furniture>();
            furnitureJobPrototypes = new Dictionary<string, Job>();

            // READ FURNITURE PROTOTYPE XML FILE HERE
            // TODO:  Probably we should be getting past a StreamIO handle or the raw
            // text here, rather than opening the file ourselves.

            string filePath = System.IO.Path.Combine(Application.streamingAssetsPath, "Data");
            filePath = System.IO.Path.Combine(filePath, "Furniture.xml");
            string furnitureXmlText = System.IO.File.ReadAllText(filePath);

            XmlTextReader reader = new XmlTextReader(new StringReader(furnitureXmlText));

            int furnCount = 0;
            if (reader.ReadToDescendant("Furnitures"))
            {
                if (reader.ReadToDescendant("Furniture"))
                {
                    do
                    {
                        furnCount++;

                        Furniture furn = new Furniture();
                        furn.ReadXmlPrototype(reader);

                        furniturePrototypes[furn.objectType] = furn;



                    } while (reader.ReadToNextSibling("Furniture"));
                }
                else
                {
                    Debug.LogError("The furniture prototype definition file doesn't have any 'Furniture' elements.");
                }
            }
            else
            {
                Debug.LogError("Did not find a 'Furnitures' element in the prototype definition file.");
            }

            Debug.Log("Furniture prototypes read: " + furnCount.ToString());

            // This bit will come from parsing a LUA file later, but for now we still need to
            // implement furniture behaviour directly in C# code.
            //furniturePrototypes["Door"].RegisterUpdateAction( FurnitureActions.Door_UpdateAction );
            //furniturePrototypes["Door"].IsEnterable = FurnitureActions.Door_IsEnterable;

        }

        public bool IsFurniturePlacementValid(string furnitureType, Tile t)
        {
            return furniturePrototypes[furnitureType].IsValidPosition(t);
        }
        #endregion Furniture

        internal Furniture PlaceFurniture(string objectType, Tile t, bool doRoomFloodFill = true)
        {
            //Debug.Log("PlaceInstalledObject");
            // TODO: This function assumes 1x1 tiles -- change this later!

            if (furniturePrototypes.ContainsKey(objectType) == false)
            {
                Utils.LogError("furniturePrototypes doesn't contain a proto for key: " + objectType);
                return null;
            }

            Furniture furn = Furniture.PlaceInstance(furniturePrototypes[objectType], t);

            if (furn == null)
            {
                // Failed to place object -- most likely there was already something there.
                return null;
            }

            furn.RegisterOnRemovedCallback(OnFurnitureRemoved);
            AddEntity(furn);

            // Do we need to recalculate our rooms?
            if (doRoomFloodFill && furn.roomEnclosure)
            {
                Room.DoRoomFloodFill(furn.tile);
            }



            if (cbFurnitureCreated != null)
            {
                cbFurnitureCreated(furn);

                if (furn.movementCost != 1)
                {
                    // Since tiles return movement cost as their base cost multiplied
                    // buy the furniture's movement cost, a furniture movement cost
                    // of exactly 1 doesn't impact our pathfinding system, so we can
                    // occasionally avoid invalidating pathfinding graphs
                    InvalidateTileGraph();	// Reset the pathfinding system
                }
            }

            return furn;
        }

      

        internal void AddRoom(Room newRoom)
        {
            newRoom.chunk.AddRoom(newRoom);
        }
    }
}



--------- ARQ: MovableEntity
        void Update_DoMovement(float deltaTime)
        {
            if (currTile == DestTile || DestTile==null)
            {
                pathAStar = null;
                return; // We're already were we want to be.
            }
            hasChanged = true;

            // currTile = The tile I am currently in (and may be in the process of leaving)
            // nextTile = The tile I am currently entering
            // destTile = Our final destination -- we never walk here directly, but instead use it for the pathfinding

            if (nextTile == null || nextTile == currTile)
            {
                // Get the next tile from the pathfinder.
                if (pathAStar == null || pathAStar.Length() == 0)
                {
                    // Generate a path to our destination
                    pathAStar = new Path_AStar(World.Current, currTile, DestTile);  // This will calculate a path from curr to dest.
                    if (pathAStar.Length() == 0)
                    {
                        Debug.LogError("Path_AStar returned no path to destination!");
                        AbandonJob();
                        return;
                    }

                    // Let's ignore the first tile, because that's the tile we're currently in.
                    nextTile = pathAStar.Dequeue();

                }


                // Grab the next waypoint from the pathing system!
                nextTile = pathAStar.Dequeue();

                if (nextTile == currTile)
                {
                    Debug.LogError("Update_DoMovement - nextTile is currTile?");
                }
            }

            /*		if(pathAStar.Length() == 1) {
                        return;
                    }
            */
            // At this point we should have a valid nextTile to move to.

            // What's the total distance from point A to point B?
            // We are going to use Euclidean distance FOR NOW...
            // But when we do the pathfinding system, we'll likely
            // switch to something like Manhattan or Chebyshev distance
            float distToTravel = Mathf.Sqrt(
                Mathf.Pow(currTile.X - nextTile.X, 2) +
                Mathf.Pow(currTile.Y - nextTile.Y, 2)
            );

            if (nextTile.IsEnterable() == GameConsts.ENTERABILITY.Never)
            {
                // Most likely a wall got built, so we just need to reset our pathfinding information.
                // FIXME: Ideally, when a wall gets spawned, we should invalidate our path immediately,
                //		  so that we don't waste a bunch of time walking towards a dead end.
                //		  To save CPU, maybe we can only check every so often?
                //		  Or maybe we should register a callback to the OnTileChanged event?
                Debug.LogError("FIXME: A character was trying to enter an unwalkable tile.");
                nextTile = null;    // our next tile is a no-go
                pathAStar = null;   // clearly our pathfinding info is out of date.
                return;
            }
            else if (nextTile.IsEnterable() == GameConsts.ENTERABILITY.Soon)
            {
                // We can't enter the NOW, but we should be able to in the
                // future. This is likely a DOOR.
                // So we DON'T bail on our movement/path, but we do return
                // now and don't actually process the movement.
                return;
            }

            // How much distance can be travel this Update?
            float distThisFrame = speed / nextTile.movementCost * deltaTime;

            // How much is that in terms of percentage to our destination?
            float percThisFrame = distThisFrame / distToTravel;

            // Add that to overall percentage travelled.
            movementPercentage += percThisFrame;

            if (movementPercentage >= 1)
            {
                // We have reached our destination

                // TODO: Get the next tile from the pathfinding system.
                //       If there are no more tiles, then we have TRULY
                //       reached our destination.

                currTile = nextTile;
                movementPercentage = 0;
                // FIXME?  Do we actually want to retain any overshot movement?
            }


        }

-----------ARQ: GameCharacter:::


using System;
using System.Collections.Generic;
using System.Xml;
using MoonSharp.Interpreter;
using Newtonsoft.Json.Linq;
using ProjectPorcupine.Localization;
using UnityEngine;

namespace MineFort.model.entities
{
    [MoonSharpUserData]
    public class GameCharacter : MovableEntity, ISelectable, IContextActionProvider, IUpdatable
    {
        public GameCharacter()
            : base()
        {
        }


        public override void Update(float deltaTime)
        {
            base.Update(deltaTime);

            Update_DoJob(deltaTime);
        }

        void GetNewJob()
        {

            myJob = World.Current.jobQueue.Dequeue();
            if (myJob == null)
                return;

            DestTile = myJob.tile;
            myJob.RegisterJobStoppedCallback(OnJobStopped);

            // Immediately check to see if the job tile is reachable.
            // NOTE: We might not be pathing to it right away (due to 
            // requiring materials), but we still need to verify that the
            // final location can be reached.

            pathAStar = new Path_AStar(World.current, currTile, DestTile);  // This will calculate a path from curr to dest.
            if (pathAStar.Length() == 0)
            {
                Debug.LogError("Path_AStar returned no path to target job tile!");
                AbandonJob();
                DestTile = currTile;
            }
        }

        public override void AbandonJob()
        {
            base.AbandonJob();
            World.current.jobQueue.Enqueue(myJob);
            myJob = null;
        }

        void OnJobStopped(Job j)
        {
            // Job completed (if non-repeating) or was cancelled.

            j.UnregisterJobStoppedCallback(OnJobStopped);

            if (j != myJob)
            {
                Debug.LogError("Character being told about job that isn't his. You forgot to unregister something.");
                return;
            }

            myJob = null;
        }

        float jobSearchCooldown = 0;

        Job myJob;

        void Update_DoJob(float deltaTime)
        {
            // Do I have a job?
            jobSearchCooldown -= Time.deltaTime;
            if (myJob == null)
            {
                if (jobSearchCooldown > 0)
                {
                    // Don't look for job now.
                    return;
                }

                GetNewJob();

                if (myJob == null)
                {
                    // There was no job on the queue for us, so just return.
                    jobSearchCooldown = UnityEngine.Random.Range(0.1f, 0.5f);
                    DestTile = currTile;
                    return;
                }
            }

            // We have a job! (And the job tile is reachable)

            // STEP 1: Does the job have all the materials it needs?
            if (myJob.HasAllMaterial() == false)
            {
                // No, we are missing something!

                // STEP 2: Are we CARRYING anything that the job location wants?
                if (inventory != null)
                {
                    if (myJob.DesiresInventoryType(inventory) > 0)
                    {
                        // If so, deliver the goods.
                        //  Walk to the job tile, then drop off the stack into the job.
                        if (currTile == myJob.tile)
                        {
                            // We are at the job's site, so drop the inventory
                            World.current.inventoryManager.PlaceInventory(myJob, inventory);
                            myJob.DoWork(0); // This will call all cbJobWorked callbacks, because even though
                                             // we aren't progressing, it might want to do something with the fact
                                             // that the requirements are being met.

                            // Are we still carrying things?
                            if (inventory.stackSize == 0)
                            {
                                inventory = null;
                            }
                            else
                            {
                                Debug.LogError("Character is still carrying inventory, which shouldn't be. Just setting to NULL for now, but this means we are LEAKING inventory.");
                                inventory = null;
                            }

                        }
                        else
                        {
                            // We still need to walk to the job site.
                            DestTile = myJob.tile;
                            return;
                        }
                    }
                    else
                    {
                        // We are carrying something, but the job doesn't want it!
                        // Dump the inventory at our feet
                        // TODO: Actually, walk to the nearest empty tile and dump it there.
                        if (World.current.inventoryManager.PlaceInventory(currTile, inventory) == false)
                        {
                            Debug.LogError("Character tried to dump inventory into an invalid tile (maybe there's already something here.");
                            // FIXME: For the sake of continuing on, we are still going to dump any
                            // reference to the current inventory, but this means we are "leaking"
                            // inventory.  This is permanently lost now.
                            inventory = null;
                        }
                    }
                }
                else
                {
                    // At this point, the job still requires inventory, but we aren't carrying it!

                    // Are we standing on a tile with goods that are desired by the job?
                    if (currTile.inventory != null &&
                        (myJob.canTakeFromStockpile || currTile.furniture == null || currTile.furniture.IsStockpile() == false) &&
                        myJob.DesiresInventoryType(currTile.inventory) > 0)
                    {
                        // Pick up the stuff!
                        Debug.Log("Pick up the stuff");

                        World.current.inventoryManager.PlaceInventory(
                            this,
                            currTile.inventory,
                            myJob.DesiresInventoryType(currTile.inventory)
                        );

                    }
                    else
                    {
                        // Walk towards a tile containing the required goods.
                        Debug.Log("Walk to the stuff");
                        Debug.Log(myJob.canTakeFromStockpile);


                        // Find the first thing in the Job that isn't satisfied.
                        GameInventory desired = myJob.GetFirstDesiredInventory();

                        if (currTile != nextTile)
                        {
                            // We are still moving somewhere, so just bail out.
                            return;
                        }

                        // Any chance we already have a path that leads to the items we want?
                        if (pathAStar != null && pathAStar.EndTile() != null && pathAStar.EndTile().inventory != null && pathAStar.EndTile().inventory.objectType == desired.objectType)
                        {
                            // We are already moving towards a tile that contains what we want!
                            // so....do nothing?
                        }
                        else
                        {
                            Path_AStar newPath = World.current.inventoryManager.GetPathToClosestInventoryOfType(
                                desired.objectType,
                                currTile,
                                desired.maxStackSize - desired.stackSize,
                                myJob.canTakeFromStockpile
                            );

                            if (newPath == null)
                            {
                                //Debug.Log("pathAStar is null and we have no path to object of type: " + desired.objectType);
                                // Cancel the job, since we have no way to get any raw materials!
                                AbandonJob();
                                return;
                            }


                            Debug.Log("pathAStar returned with length of: " + newPath.Length());

                            if (newPath == null || newPath.Length() == 0)
                            {
                                Debug.Log("No tile contains objects of type '" + desired.objectType + "' to satisfy job requirements.");
                                AbandonJob();
                                return;
                            }

                            DestTile = newPath.EndTile();

                            // Since we already have a path calculated, let's just save that.
                            pathAStar = newPath;

                            // Ignore first tile, because that's what we're already in.
                            nextTile = newPath.Dequeue();
                        }

                        // One way or the other, we are now on route to an object of the right type.
                        return;
                    }

                }

                return; // We can't continue until all materials are satisfied.
            }
        }
    }
}
